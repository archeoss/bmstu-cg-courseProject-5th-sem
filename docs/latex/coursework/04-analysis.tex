\section{Аналитический раздел}

В данной части проводится анализ объектов сцены и существующих
алгоритмов построения изображений и выбор более подходящих алгоритмов
для дальнейшего использования.
\subsection{Описание объектов сцены}

Сцена состоит из следующих объектов:
\begin{itemize}
    \item[$-$] \textbf{Камера} -- объект, с которого осуществляется наблюдение за сценой. Характеризуется своим пространственным положением, направлением просмотра, углом обзора, ближним и дальним границами обзора.
    \item[$-$] \textbf{Источник света} -- объект, который освещает сцену. Направленный источник света представляет собой вектор направления света и принимает ортогональную проекцию визуализируемой сцены из своего положения с некоторым ограниченным положением. 
В зависимости от расположения источника и направления распространения лучей света, определяется тень от объекта, расположенных на сцене.
    \item[$-$] \textbf{Модель} -- сущность, которая может быть отображена на сцене. Примитивные тела вращения, расположенные в пространстве сцены. Каждая модель представляет собой набор граней, описываемых точками в пространстве, которые соединены ребрами.
    \item[$-$] \textbf{Композит} -- объект, который может содержать в себе другие объекты.
\end{itemize}

\subsection{Анализ методов создания моделей}
Тело вращения — это поверхность в евклидовом пространстве,
образованная вращением кривой (образующей) вокруг оси вращения.\cite{revolution}

На данном этапе стоит рассмотреть существующие схемы представления тел.

\subsubsection{Представление тел вращения}

Тела вращения характеризуются осью, радиусами оснований и конструктивными точками образующей поверхности тел.
Чтобы лучше разобраться в принципах конструктивного построения формы цилиндра и конуса,
следует обратить внимание на рис. \ref{img:tor} и на рис. \ref{img:frame_revol}, где они изображены в виде прозрачных проволочных моделей.
На рисунках ясно выражены конструктивная основа и объемно-пространственная характеристика формы предметов.
Задача состоит в том, чтобы реализовать грамотное и правильное изображение тел на сцене.

\img{60mm}
{tor} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{Проволочная модель тора} % Подпись рисунка

\img{100mm}
{frame_revol} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{Различные проволочные модели} % Подпись рисунка

Тело вращения образуется вращательной разверткой кривой профиля C вокруг оси. Если поверхность задается с помощью:\newline

\begin{equation}
P(u, v) = (X(v)cos(u), X(v)sin(u), Z(v))
\end{equation}
где X и Z - функции, тогда вектор нормали может быть задан через:\newline

\begin{equation}
n(u, v) = X(v) (Z' (v)cos(u), Z' (v)sin(u), - X' (v))
\end{equation}

где апостроф обозначает первую производную функции.

%\img{100mm}
%{rotate_profile} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
%{f} % Обтекание (с обтеканием)
%{h} % Положение рисунка (см. wrapfigure из пакета wrapfig)
%{0.5\textwidth} % Ширина рисунка
%{Профиль вращения} % Подпись рисунка

\subsection{Способы описания трехмерных геометрических моделей на сцене}

В компьютерной графики для описание трехмерных геометрических объектов существует три типа моделей: каркасная, поверхностная и твердотельная~\cite{aaymodelmethod}. Использование моделей позволяет правильно отображать форму и размеры объектов сцены.

\begin{itemize}
	\item \textit{Каркасная модель} --- простейший вид моделей, который содержит минимум информации только о вершинах и ребрах объектов. Это моделирование самого низкого уровня, которое имеет ряд серьезных ограничений, большинство из которых возникает из-за недостатка информации о гранях, которые заключены между ребрами. Невозможно выделить внутреннюю и внешнюю область изображения твердого объемного тела. Однако каркасная модель требует меньше памяти и затрат времени на построение, что достаточно пригодна для решения задач, не требующие информации о поверхности объекта (например, если в объекте есть отверстия). Проблемой этой модели заключается в том, что она не позволяет отличить видимые грани от невидимых. Операции по удалению невидимых линий можно выполнить только вручную с применением команд редактирования каждой отдельной линии, но результат работы нарушает каркасную конструкцию, по причине того что линии невидимы в одном случае и видимы в другом.
	Кроме того, каркасная модель не несет информации о поверхностях, ограничивающих форму, что обуславливает невозможность обнаружения нежелательных взаимодействий между гранями объекта~\cite{roders}.
	\item \textit{Поверхностная модель} часто используется в компьютерной графике, кроме содержание информации о вершинах и ребрах, содержит еще информацию о поверхности. При построении поверхностной модели предполагается, что технические объекты ограничены поверхностями, которые отделяют их от окружающей среды. 
	Недостатком поверхностной модели является отсутствие информации о том, с какой стороны поверхности находится материал.
	\item \textit{Твердотельная модель} отличается от поверхностной тем, что в данной модели к информации о поверхностях добавляется информация о том, с какой стороны расположен материал. Это достигается путем указания направления внутренней нормали.
\end{itemize}

Для решения поставленной задачи не подойдет каркасная модель, так как такое представление будет приводить к неправильному восприятию форм объекта. Твердотельная модель также не подойдет, так как по поставленной задачи нет необходимости знать из какого материала будет выполнен тот или иной объект и с какой стороны расположен материал. Поэтому выбор остается лишь поверхностной модели.

\subsection{Способы задания поверхностных моделей}

Поверхностная модель задается следующими способами~\cite{roders, porev}.
\begin{itemize}
	\item \textit{Аналитический (параметрический) способ} характеризуется описанием модели объекта, которое доступно в неявной форме,то есть для получения визуальных характеристик необходимо дополнительно вычислять некоторую функцию, которая зависит от параметра. 
	\item \textit{Полигональная сетка} характеризуется совокупностью вершин, ребер и граней, определяющих форму объекта в трехмерном пространстве.
\end{itemize}

Рассмотрим существующие способы хранения информации о полигональной сетке.

Вершинное представление описывает объект множество вершин, соединенных с другими вершинами (вершины, которые указывают на другие вершины). 
Информация о ребрах и гранях неявно присутствует в представлении из-за чего для восстановления исходного тела необходимо обойти все вершины и составить списки граней. 
Кроме того, операции с ребрами и гранями выполнить нелегко~\cite{aaymodelmethod}.
Тем не менее из-за простоты представления дает возможность множество операций над сеткой. 
Хранение информации о сетке требует не так много памяти по сравнению с другими способами.
На рисунке~\ref{img:vertex-method} представлен пример вершинного представления, рассмотренный на кубе.

\img{100mm}{vertex-method}{Вершинное представление}

Представление называемый списком граней представляет объект не только множеством вершин, но граней. 
В отличие от предыдущего способа, вершины и граны определены явно, благодаря чему нахождение соседних вершин и граней довольно проста и поиск соседних граней и вершин занимает постоянное время~\cite{aaymodelmethod}. 
Также список вершин содержит список граней, связанных с каждой вершиной. 
Однако ребра неявны, поэтому поиск все равно необходим, чтобы найти все грани, окружающие данную грань. 
Другие динамические операции, такие как разделение или слияние граней, также сложны с сетками граней и вершин. 
Пример представления список граней представлен на рисунке~\ref{img:list-faces}.

\img{100mm}{list-faces}{Список граней}

\subsubsection{Понятие поверхности вращения}

Поверхность вращения - это один из часто встречающихся типов поверхностей.
Сферы и цилиндры можно рассматривать как одни из таких аповерхностей.
В общем случае, можно получить тело вращения, вращая тело или набор тел вокруг некоторой произвольной оси.
Чтобы более подробно проанализировать, что это значит, рассмотрим самый простой объект для вращения, а именно точку.
В этом случае получается окружность в плоскости, ортогональной оси, с центром на оси и радиусом,
равным расстоянию точки до оси.\newline

Отсюда следует, что можно представить тело вращения как состоящий из объединения окружностей с центром на оси,
по одной для каждой точки вращаемого объекта.
Это также предполагает, что способ параметризации точки \textbf{P} объекта,
полученного путем вращения кривой вокруг оси, заключается в использовании двух параметров.
Один параметр - это параметр точки на кривой, которая привела к появлению \textbf{P},
а другой - угол, на который она была повернута.
Для общих объектов вращения нам понадобилось бы k + 1 параметров, где k - количество параметров,
необходимых для параметризации вращаемого объекта.

Наше фактическое определение поверхности вращения, которое будет дано в терминах параметризации,
ограничится случаем, когда кривая вращается вокруг оси x.
Это упростит определение. Кроме того, из этого можно получить поверхности вращения вокруг произвольной оси,
используя жесткие движения.

\img{100mm}
{curve} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{Поверхность вращения} % Подпись рисунка

\subsubsection{Формализация тела вращения}

Допустим, что
\begin{equation}
g: [a, b] \longrightarrow R^2
\end{equation}

будет плоской параметрической кривой и пусть

\begin{equation}
    g(t) = (g_1(t), g_2(t))
\end{equation}

Определим функцию

\begin{equation}
    p: [a, b] \times [c, d] \longrightarrow R^3
\end{equation}

как

\begin{equation}
    p(t, \theta) = (g_1(t), g_2(t)cos(\theta), g_2(t)sin(\theta))\label{eq:param}
\end{equation}

Подмножество
\begin{equation}
    X = p([a, b] \times [c, d]) \subseteq R^3
\end{equation}
называется поверхностью вращения вокруг оси x для углов c и d относительно g.\newline
Кривые
\begin{equation}
    \gamma(t) = p(t, \theta)
\end{equation}
для фиксированного \(\theta\) являются меридианами поверхности вращения и кривые
\begin{equation}
    \nu(\theta) = p(t, \theta)
\end{equation}
для фиксированного t называются кругами широты.\newline

Используя стандартную параметризацию \(g(t) = (t,f(t))\) для
графика f и замена t на x в уравнении \ref{eq:param}, поверхность, полученная путем вращения графика f вокруг оси x,
параметризуется с помощью формулы

\begin{equation}
    p(x, \theta) = (x, f(x)cos(\theta), f(x)sin(\theta))
\end{equation}

Отсюда легко вычислить производные для этой поверхности

\begin{equation}
    \frac{\delta p}{\delta x} = (1, f'(x)cos(\theta), f'(x)sin(\theta))
\end{equation}
\begin{equation}
    \frac{\delta p}{\delta \theta} = (0, -f(x)sin(\theta), f(x)cos(\theta))
\end{equation}

Из этого можно сразу узнать касательные плоскости в каждой точке,
потому что перекрестное произведение частных производных является нормальным вектором
(при условии, что частные производные не обращаются в нуль).

\subsection{Анализ алгоритмов удаления невидимых линий и поверхностей}

При выборе алгоритма удаления невидимых линий и поверхностей учитывается особенность поставленной
задачи - работа программы будет выполняться в реальном режиме при взаимодействии с пользователем.
Этот факт предъявляет к алгоритму требование по скорости работы.
Для выбора наиболее подходящего алгоритма следует рассмотреть уже имеющиеся алгоритмы удаления невидимых линий и поверхностей.

\subsubsection{Алгоритм обратной трассировки лучей}
Алгоритм работает в пространстве изображения\cite{raytr}.

Суть алгоритма: для определения цвета пиксела экрана через него из точки наблюдения проводится луч,
ищется пересечение первым пересекаемым объектом сцены и определяется освещенность точки пересечения.
Эта освещенность складывается из отраженной и преломленной энергий, полученных от источников света,
а также отраженной и преломленной энергий, идущих от других объектов сцены.
После определения освещенности найденной точки учитывается ослабление света при прохождении через прозрачный материал
и в результате получается цвет точки экрана.

Преимущества:
\begin{itemize}
    \item изображение, которое строится с учётом явлений дисперсии лучей, преломления, а также внутреннего отражения;
    \item возможность использования в параллельных вычислительных системах.
\end{itemize}

Недостатки:
\begin{itemize}
    \item трудоёмкие вычисления\cite{tracer_proof};
\end{itemize}

\subsubsection{Алгоритм, использующий Z-буфер}
Алгоритм работает в пространстве изображения\cite{zbuf}.

Сущность алгоритма: имеется 2 буфера - буфер кадра, который используется для запоминания цвета каждого
пиксела изображения, а также $z$-буфер - отдельный буфер глубины,
используемый для запоминания координаты $z$ (глубины)
каждого видимого пиксела изображения.
В процессе работы глубина или значение $z$ каждого нового пиксела,
который нужно занести в буфер кадра, сравнивается с глубиной того пиксела,
который уже занесен в $z$-буфер.
Если это сравнение показывает, что новый пиксел расположен выше пиксела,
находящегося в буфере кадра ($z > 0$),
то новый пиксел заносится в цвет рассматриваемого пиксела заносится в буфер кадра, а координата $z$ - в $z$-буфер.
По сути, алгоритм является поиском по $x$ и $y$ наибольшего значения функции $z(x, y)$.

Преимущества:
\begin{itemize}
    \item возможность обработки произвольных поверхностей, аппроксимируемых полигонами;
    \item отсутствие требования сортировки объектов по глубине.
\end{itemize}

Недостатки:
\begin{itemize}
    \item отсутствие возможности работы с прозрачными и просвечивающими объектами (в классической версии).
\end{itemize}

\subsubsection{Алгоритм Робертса}
Алгоритм работает в объектном пространстве\cite{robert}.

Суть алгоритма: алгоритм прежде всего удаляет из каждого тела те ребра или грани, которые экранируются самим телом. Затем каждое из видимых ребер каждого тела сравнивается с каждым из оставшихся тел для определения того, какая его часть или части, если таковые есть, экранируются этими телами.

Преимущества:
\begin{itemize}
    \item реализации алгоритма, использующие предварительную приоритетную сортировку вдоль оси z и простые габаритные или минимаксные тесты, демонстрируют почти линейную зависимость от числа объектов\cite{robert}.
\end{itemize}

Недостатки:
\begin{itemize}
    \item вычислительная трудоёмкость алгоритма теоретически растет, как квадрат числа объектов\cite{robert};
    \item отсутствие возможности работы с прозрачными и просвечивающими объектами.
\end{itemize}

\subsubsection*{Вывод}

В таблице \ref{tab:cmp_del} представлено сравнение алгоритмов\cite{rogers} удаления невидимых линий и поверхностей (по каждому параметру составлен рейтинг: 1 - лучший алгоритм, 3 - худший). Так как главным требованием к алгоритму является скорость работы, алгоритмы были оценены по следующим критериям:
\begin{itemize}
    \item скорость работы (С);
    \item масштабируемость с ростом количества моделей (ММ);
    \item масштабируемость с увеличением размера экрана (МЭ);
    \item работа с фигурами вращения (ФВ).
\end{itemize}

\begin{table}[!h]
    \begin{center}
        \begin{tabular}{| @{\hspace{7mm}}r@{\hspace{7mm}} | @{\hspace{7mm}}r@{\hspace{7mm}} | @{\hspace{7mm}}l@{\hspace{7mm}} | @{\hspace{7mm}}l@{\hspace{7mm}} | @{\hspace{7mm}}l@{\hspace{7mm}} |}
            \hline
            Алгоритм & С & ММ & МЭ & ФВ \\
            \hline
            Z-буфера & 1 & 2 & 1 & 1 \\
            Трассировка лучей & 3 & 1 & 3 & 2\\
            Робертса & 2 & 3 & 1 & 3\\
            \hline
        \end{tabular}
    \end{center}
    \caption{\label{tab:cmp_del} Сравнение алгоритмов удаления невидимых линий и поверхностей.}
\end{table}

С учётом результатов в таблице \ref{tab:cmp_del} был выбран алгоритм \textbf{Z-буфера} удаления невидимых линий и поверхностей.

% \subsection{Бинарные операции над телами}
%
% \subsubsection{CTIN}
% Для описания гомогенных объектов можно
% использовать граничную модель, определяя
% границу как множество многоугольников. Частным случаем граничной модели является модель трехмерного тела, у которого граница
% представляет собой замкнутое множество нерегулярных треугольников.
% Замкнутую ориентированную поверхность Р разобьем на треугольники со следующими условиями:
% \begin{enumerate}
%     \item каждая точка поверхности Р принадлежит хотя бы одному треугольнику;
%     \item два треугольника могут пересекаться только в одной вершине или по целому ребру.
% \end{enumerate}
%
% Такую модель будем называть
% CTIN-представлением или CTIN-поверхностью
% (CTIN — closed triangular irregular network).\cite{binary_CTIN}\newline
%
% На рис. \ref{img:triang} изображены верхняя и боковая триангулированные поверхности слоя.
%
% В результате любой булевой операции над двумя CTIN-поверхностями можно получить новую CTIN-поверхность
%
% \img{100mm}
% {triang} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
% {Триангулированная поверхность слоя} % Подпись рисунка
%
% \img{100mm}
% {triang_hard} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
% {Сложная триангулированная поверхность} % Подпись рисунка
%
% \subsubsection{Улучшенный Z-буффер}
% Другим подходом является путь улучшенной Z-буфферизации.
% Конструктивная геометрия твердого тела (CSG) - это подход к геометрическому
% моделированию. CSG упорядочивает логические операции и примитивные объекты
% в виде дерева. Узлы (или нетерминалы) дерева представляют
% логические операции, а листья (или терминалы) представляют объекты.
% Логическими операциями, используемыми в CSG, являются объединение (\(\cup\)), пересечение
% (\(\cap\)) и разница (-). Аффинные преобразования, такие как масштабирование, перемещение и поворот,
% также могут быть связаны с каждым узлом дерева. На рис. \ref{img:csg_tree} показан абстрактный объект CSG, заданный в терминах коробок,
% сфер и цилиндров. \cite{binary_Z}
%
% \img{100mm}
% {csg_tree} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
% {CSG-дерево} % Подпись рисунка
%
% В связи с выбранным ранее алгоритмом удаления невидимых линий в виде Z-буффера, был выбран именно этот способ
%
\subsection{Анализ методов закрашивания}

Методы закрашивания используются для затенения полигонов
(или поверхностей, аппроксимированных полигонами)
в условиях некоторой сцены, имеющей источники освещения.

\subsubsection{Простая закраска}

Суть алгоритма: вся грань закрашивается одним уровнем интенсивности,
который зависит высчитывается по закону Ламберта\cite{rogers}.
При данной закраске все плоскости (в том числе и те,
что аппроксимируют фигуры вращения),
будут закрашены однотонно,
что в случае с фигурами вращения будет давать ложные ребра.

Преимущества:
\begin{itemize}
    \item используется для работы с многогранниками, обладающими преимущественно диффузным отражением.
\end{itemize}

Недостатки:

\begin{itemize}
    \item плохо подходит для фигур вращения: видны ребра.
\end{itemize}

\subsubsection{Закраска по Гуро}
Суть алгоритма: билинейная интерполяция в каждой точке интенсивности освещения в вершинах\cite{lmodels}.

Нормаль к вершине можно найти несколькими способами:
\begin{itemize}
    \item интерполировать нормали прилегающих к вершине граней;
    \item использовать геометрические свойства фигуры (так, например, в случае со сферой ненормированный вектор нормали будет в точности соответствовать вектору от центра сферы до рассматриваемой точки).
\end{itemize}

После нахождения нормали ко всем вершинам находится интенсивность в каждой вершине по закону Ламберта.
Затем алгоритм проходится сканирующими строками по рассматриваемому полигону для всех $y: y \in [y_{min}; y_{max}]$. Каждая сканирующая строка пересекает 2 ребра многоугольника, пусть для определённости это будут ребра через одноименные вершины: $MN$ и $KL$. В точках пересечения высчитывается интенсивность путём интерполяции интенсивности в вершинах.
Так, для точки пересечения с ребром $MN$ интенсивность будет рассчитана как (\ref{for:int_mn}):
\begin{equation}
    \label{for:int_mn}
    I_{MN} = \frac{l_1}{l_0} \cdot I_M + \frac{l_2}{l_0} \cdot I_N
\end{equation}
где $l_1$ - расстояние от точки пересечения до вершины $N$, $l_2$ - расстояние от точки пересечения до вершины $M$, $l_0$ - длина ребра $MN$.
Для точки пересечения сканирующей строки с ребром $KL$ интенсивность высчитывается аналогично.

Далее, после нахождения точек пересечения, алгоритм двигается по $Ox$ от левой точки пересечения $X_{left}$ до правой точки пересечения $X_{right}$ и в каждой точке $\mathcal{X}$ интенсивность рассчитывается как (\ref{for:int_x}):
\begin{equation}
    \label{for:int_x}
    I_{\mathcal{X}} = \frac{\mathcal{X} - X_{left}}{X_{right} - X_{left}} \cdot I_{X_{right}} + \frac{X_{right} - \mathcal{X}}{X_{right} - X_{left}} \cdot I_{X_{left}}
\end{equation}

Преимущества:
\begin{itemize}
    \item преимущественно используется с фигурами вращения с диффузным отражением, аппроксимированными полигонами.
\end{itemize}

Недостатки:
\begin{itemize}
    \item при закраске многогранников ребра могут стать незаметными.
\end{itemize}

\subsubsection{Закраска по Фонгу}
Суть алгоритма: данный алгоритм работает похожим на алгоритм Гуро образом, однако ключевым отличием является то, что интерполируются не интенсивности в вершинах, а нормали\cite{lmodels}. Таким образом, закон Ламберта в данном алгоритме применяется в каждой точке, а не только в вершинах, что делает этот алгоритм гораздо более трудоёмким, однако с его помощью можно гораздо лучше изображаются блики.

Преимущества:
\begin{itemize}
    \item преимущественно используется с фигурами вращения с зеркальным отражением, аппроксимированными полигонами.
\end{itemize}

Недостатки:
\begin{itemize}
    \item самый трудоёмкий алгоритм из рассмотренных\cite{rogers}.
\end{itemize}

\subsubsection*{Вывод}

В таблице \ref{tab:cmp_paint} представлено сравнение алгоритмов\cite{rogers} закраски (по каждому параметру составлен рейтинг: 1 - лучший алгоритм, 3 - худший). Так как требованиями к алгоритму являются высокая скорость работы, а также возможность закраски фигур вращения с диффузными свойствами отражения, алгоритмы были оценены по следующим критериям:
\begin{itemize}
    \item скорость работы (С);
    \item работа с фигурами вращения (ФВ);
    \item работа с фигурами со свойствами диффузного отражения (ДО).
\end{itemize}

\begin{table}[!h]
    \begin{center}
        \begin{tabular}{| @{\hspace{7mm}}r@{\hspace{7mm}} | @{\hspace{7mm}}r@{\hspace{7mm}} | @{\hspace{7mm}}l@{\hspace{7mm}} | @{\hspace{7mm}}l@{\hspace{7mm}} |}
            \hline
            Алгоритм & С & ФВ & ДО \\
            \hline
            Простой & 1 & 3 & 1 \\
            Гуро & 2 & 1 & 1 \\
            Фонга & 3 & 1 & 3 \\
            \hline
        \end{tabular}
    \end{center}
    \caption{\label{tab:cmp_paint} Сравнение алгоритмов закраски.}
\end{table}

С учётом результатов в таблице \ref{tab:cmp_paint} был выбран алгоритм закраски \textbf{Гуро}.

%\subsection{Обработка изображения}
%
%Есть 2 основных варианта обработки изображения: рендеринг на центральном и графическом процессорах.
%Они имеет много общего, но существуют различия, которые оказывают огромное влияние на скорость и качество изображения.
%Рендеринг на базе ЦП является традиционным способом и широко используется.
%Напротив, рендеринг с помощью графических процессоров с годами
%становится все более популярным в сообществе благодаря быстроразвивающемуся миру технологий.
%
%\subsubsection{CPU}
%
%CPU — центральный процессор, это основной компонент компьютера, обрабатывающий инструкции.
%Он выполняет вычисления, действия, запускает программы, включая рендеринг. Центральный процессор постоянно
%принимает ввод от пользователя или активных программ, затем обрабатывает данные и выдает вывод,
%который может быть сохранен приложением или
%отображен на экране.
%
%\subsubsection{GPU}
%
%GPU — графический процессор. Разработан для параллельной обработки трудоёмких вычислительных задач.
%Графический процессор используется в широком спектре приложений, ускоряющих рендеринг 3D-графики.
%Кроме того, этот микропроцессор также используется для разгрузки некоторых задач с центрального процессора,
%что заставляет компьютер работать быстрее.
%
%\subsubsection{Сравнение процессоров}
%Рассмотрим различия процессоров приминительно к рендеру:
%1) главное различие между процессорами CPU и GPU заключается в том,
%как каждый из них выполняет разные задачи;
%2) архитектурно CPU состоит всего из нескольких ядер с большим количеством кэш­памяти, которая может обрабатывать несколько программных
%потоков одновременно, Напротив, графический процессор состоит из сотен
%меньших и более эффективных ядер, которые могут одновременно выполнять
%несколько задач и быстрее обрабатывать изображения;
%3) рендеринг с помощью графического процессора более эффективен с
%точки зрения задач обработки, требующих нескольких параллельных процессов, фактически, рендеринг GPU примерно в 10­100 раз быстрее, чем рендеринг CPU;
%4) GPU позволяет в реальном времени просматривать и манипулировать
%3D моделями, источниками света и проекциями в трех измерениях. Некоторое программное обеспечение для рендеринга, предназначенное только для
%графического процессора, может даже позволить полностью работать в окне
%просмотра с включенным Real Time рендерингом, увеличивая результат и минимизируя возможные ошибки, которые могут возникнуть при рендеринге в
%другой программе. CPU же не позволяет рендерить в реальном времени качественные изображения.
%Изначальная цель заключалась в создании приложения для рендера 3D
%модели в режиме реального времени. Такой сценарий позволяет осуществить
%рендеринг на видеокарте, следовательно, для поставленной задачи следует
%выбрать её, а не CPU

\subsection*{Вывод}

В данном разделе были формально описаны тела и поверхности вращения, их структурные характеристики, по которым эти модели строятся,
были рассмотрены алгоритмы удаления невидимых линий и поверхностей,
методы закрашивания поверхностей.
В качестве алгоритма удаления невидимых линий и поверхностей был выбран алгоритм Z-буфера,
в качестве метода закрашивания был выбран алгоритм закраски Гуро.
